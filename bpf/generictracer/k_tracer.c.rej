diff a/bpf/generictracer/k_tracer.c b/bpf/generictracer/k_tracer.c	(rejected hunks)
@@ -389,39 +391,39 @@ int BPF_KPROBE(beyla_kprobe_tcp_rate_check_app_limited, struct sock *sk) {
         s_args.p_conn.pid = pid_from_pid_tgid(id);
         s_args.orig_dport = orig_dport;
 
-        msg_buffer_t *m_buf = bpf_map_lookup_elem(&msg_buffers, &e_key);
-        if (m_buf) {
-            u8 *buf = m_buf->buf;
-            // The buffer setup for us by a sock_msg program is always the
-            // full buffer, but when we extend a packet to be able to inject
-            // a Traceparent field, it will actually be split in 3 chunks:
-            // [before the injected header],[70 bytes for 'Traceparent...'],[the rest].
-            // We don't want the handle_buf_with_connection logic to run more than
-            // once on the same data, so if we find a buf we send all of it to the
-            // handle_buf_with_connection logic and then mark it as seen by making
-            // m_buf->pos be the size of the buffer.
-            if (!m_buf->pos) {
-                u16 size = sizeof(m_buf->buf);
-                m_buf->pos = size;
-                s_args.size = size;
-                bpf_dbg_printk("msg_buffer: size %d, buf[%s]", size, buf);
-                u64 sock_p = (u64)sk;
-                bpf_map_update_elem(&active_send_args, &id, &s_args, BPF_ANY);
-                bpf_map_update_elem(&active_send_sock_args, &sock_p, &s_args, BPF_ANY);
-                // must set that any backup buffer on this connection is invalid
-                // to avoid replay
-                make_inactive_sk_buffer(&s_args.p_conn.conn);
-
-                // Logically last for !ssl.
-                handle_buf_with_connection(
-                    ctx, &s_args.p_conn, buf, size, NO_SSL, TCP_SEND, orig_dport);
-            }
-        }
-
         connect_ssl_to_connection(id, &s_args.p_conn, TCP_SEND, orig_dport);
 
         void *ssl = is_ssl_connection(&s_args.p_conn);
-        if (ssl) {
+        if (!ssl) {
+            msg_buffer_t *m_buf = bpf_map_lookup_elem(&msg_buffers, &e_key);
+            if (m_buf) {
+                u8 *buf = m_buf->buf;
+                // The buffer setup for us by a sock_msg program is always the
+                // full buffer, but when we extend a packet to be able to inject
+                // a Traceparent field, it will actually be split in 3 chunks:
+                // [before the injected header],[70 bytes for 'Traceparent...'],[the rest].
+                // We don't want the handle_buf_with_connection logic to run more than
+                // once on the same data, so if we find a buf we send all of it to the
+                // handle_buf_with_connection logic and then mark it as seen by making
+                // m_buf->pos be the size of the buffer.
+                if (!m_buf->pos) {
+                    u16 size = sizeof(m_buf->buf);
+                    m_buf->pos = size;
+                    s_args.size = size;
+                    bpf_dbg_printk("msg_buffer: size %d, buf[%s]", size, buf);
+                    u64 sock_p = (u64)sk;
+                    bpf_map_update_elem(&active_send_args, &id, &s_args, BPF_ANY);
+                    bpf_map_update_elem(&active_send_sock_args, &sock_p, &s_args, BPF_ANY);
+                    // must set that any backup buffer on this connection is invalid
+                    // to avoid replay
+                    make_inactive_sk_buffer(&s_args.p_conn.conn);
+
+                    // Logically last for !ssl.
+                    handle_buf_with_connection(
+                        ctx, &s_args.p_conn, buf, size, NO_SSL, TCP_SEND, orig_dport);
+                }
+            }
+        } else {
             make_inactive_sk_buffer(&s_args.p_conn.conn);
             tcp_send_ssl_check(id, ssl, &s_args.p_conn, orig_dport);
         }
