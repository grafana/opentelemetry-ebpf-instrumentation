diff a/bpf/common/trace_common.h b/bpf/common/trace_common.h	(rejected hunks)
@@ -248,21 +251,24 @@ static __always_inline u8 find_trace_for_server_request(connection_info_t *conn,
 
         if (!disable_black_box_cp && correlated_requests(tp, existing_tp)) {
             if (existing_tp->valid) {
-                found_tp = 1;
                 bpf_dbg_printk("Found existing correlated tp for server request");
-                __builtin_memcpy(tp->trace_id, existing_tp->tp.trace_id, sizeof(tp->trace_id));
-                __builtin_memcpy(tp->parent_id, existing_tp->tp.span_id, sizeof(tp->parent_id));
                 // Mark the client info as invalid (used), in case the client
                 // request information is not cleaned up.
-                if ((type == EVENT_HTTP_REQUEST && existing_tp->req_type == EVENT_HTTP_CLIENT) &&
+                if ((type == EVENT_HTTP_REQUEST && existing_tp->req_type == EVENT_HTTP_CLIENT) ||
                     (type == EVENT_TCP_REQUEST && existing_tp->req_type == EVENT_TCP_REQUEST)) {
+                    found_tp = 1;
+                    __builtin_memcpy(tp->trace_id, existing_tp->tp.trace_id, sizeof(tp->trace_id));
+                    __builtin_memcpy(tp->parent_id, existing_tp->tp.span_id, sizeof(tp->parent_id));
                     // We ensure that server requests match the client type, otherwise SSL
                     // can often be confused with TCP.
                     existing_tp->valid = 0;
                     set_trace_info_for_connection(conn, TRACE_TYPE_CLIENT, existing_tp);
                     bpf_dbg_printk("setting the client info as used");
                 } else {
-                    bpf_dbg_printk("incompatible trace info, not using the correlated tp");
+                    bpf_dbg_printk("incompatible trace info, not using the correlated tp, type %d, "
+                                   "other type %d",
+                                   type,
+                                   existing_tp->req_type);
                 }
             } else {
                 bpf_dbg_printk("the existing client tp was already used, ignoring");
